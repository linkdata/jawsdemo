<!doctype html>
<html lang="en">

<head>
	{{template "head.html" .}}
</head>

<!--
	When executing the template, we provide an *UiState as it's data parameter.
	The UiState, in turn, embeds a *jaws.Request without a member name, so it's
	methods are exposed directly on the UiState.

	You'll note that when we call those methods, we prefix the method with "$",
	which is the template syntax for "use the top-level data parameter".
-->

<body>
	{{template "header.html" .}}
	<div class="container">
		<!-- if Bootstrap is in use this marks where jaws UI alerts should be rendered -->
		<div id="jaws-alerts"></div>

		<!--
			JaWS allows several ways to register a HTML element and render it's HTML code.
			If you don't need to listen to events from the client browser, the following
			method may be a good choice. 

			It calls jaws.Request.A() via UiState.Request. Two parameters are required,
			plus a variable number of optional parameters.
			
			The first parameter is the tags you want to associate with the UI element.
			Tags can be anything (interface{}), but we treat some types special.
			Here, we just call CarsLinkID and use it's return value.

			If a string is given, it is split on spaces into multiple tags.
			For a slice of strings, we iterate over them and again split on spaces.
			A slice of interface{} will have all it's contents as tags.

			If no tag is provided (nil or an empty string), a unique string tag is
			generated for you.

			The second parameter is the HTML code to display inside the <a> element.
			Here we call CarsLinkText and have it return it.

			Finally, we provide a string with HTML attributes as the optional
			parameters. The optional parameters can contain other things as well,
			but strings are expected to be HTML attributes.
		-->
		{{$.A .CarsLinkID .CarsLinkText `href="/cars" class="btn btn-primary"`}}

		<form autocomplete="off">
			<div class="mb-3">
				<!--
					If you prefer to move data references away from the HTML template
					another option is to use jaws.Request.UI(), which accepts an
					object implementing the `jaws.UI` interface and zero or more
					data objects (normally a list of HTML attributes).

					This allows for building types for generic use, and then
					use those types directly in your structures instead of the
					primitive data types.

					.G.InputText here is an example of one such implementation.
				-->
				<label class="form-label">Text</label>
				{{$.UI .G.InputText `class="form-control"`}}
			</div>
			<div class="mb-3">
				<!--
					If jaws.Request doesn't have a helper function for a HTML tag, you can still
					use it. Here, we use Request.OnInput() to have JaWS call the function returned by
					OnInputTextArea() when the textarea data changes.
				-->
				<textarea jid="{{.G.InputTextAreaID}}" rows="4" cols="50">{{.G.InputTextArea}}</textarea>
				{{$.OnInput .G.InputTextAreaID .G.OnInputTextArea}}
			</div>
			<div class="row mb-3">
				<label for="{{.G.InputRangeID}}" class="col-sm-2 form-label">Range</label>
				<div class="col-sm-10">
					<!--
						Previous UI elements have consisted of only one HTML element,
						but this one shows that you can of course return HTML from
						JawsUi() that renders several and use an input event function
						to them in synch.
					-->
					{{$.Ui .G.InputRange `class="form-range align-bottom w-75"`}}
				</div>
			</div>
			<div class="form-check mb-3">
				{{$.Ui .G.InputCheckbox `class="form-check-input"`}}
			</div>
			<div class="mb-3">
				{{$.Ui .G.InputDate `class="form-label"`}}
			</div>
			<!--
				Radio buttons require special handling because selecting
				one in a group of several de-selects all the others, and
				keeping this in sync with the server and other browsers
				takes care.

				You can either handle this yourself using Request.Radio(),
				using the boolean event functions for the individual radio
				buttons and coordinating in your server, or use the
				Request.RadioGroup(). Here, we will use the latter.

				RadioGroup() requires an object implementing jaws.RadioGrouper
				and returns a slice of jaws.Radio, which we use to render the HTML
				entities with the Radio() and Label() methods.
			-->
			{{range $.RadioGroup .G.InputRadioGroup1}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}
			{{range $.RadioGroup .G.InputRadioGroup2}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}

			<div class="mb-3">
				<label>Choose a pet:</label>
				{{$.Ui .G.SelectPet `class="form-select"`}}
			</div>
			{{$.Ui .G.InputButton `class="btn btn-primary mt-3"`}}

			<!--
				What this does is left as an exercise to the reader.
				Hint: It's connected to the mystical button in "cars.html".
			-->
			{{$.OnEvent .G.SetInputButtonID .G.OnSetInputButton}}
		</form>
	</div>
</body>

</html>