<!doctype html>
<html lang="en">

<head>
	{{template "head.html" .}}
</head>

<!--
	When executing the template, we provide an *UiState as it's data parameter.
	The UiState, in turn, embeds a *jaws.Request without a member name, so it's
	methods are exposed directly on the UiState.

	You'll note that when we call those methods, we prefix the method with "$",
	which is the template syntax for "use the top-level data parameter".
-->

<body>
	{{template "header.html" .}}
	<div class="container">
		<!-- if Bootstrap is in use this marks where jaws UI alerts should be rendered -->
		<div id="jaws-alerts"></div>

		<!--
			JaWS allows several ways to register a HTML element and render it's HTML code.
			If you don't need to listen to events from the client browser, the following
			method may be a good choice. 

			It calls jaws.Request.A() via UiState.Request. Two parameters are required,
			plus a variable number of optional parameters.
			
			The first parameter is the tags you want to associate with the UI element.
			Tags are used when letting JaWS know which Elements need to be updated.
			Tags can be anything (interface{}), but we treat some types special:

			If a string is given, it is split on spaces into multiple tags.
			For a slice of strings, we iterate over them and again split on spaces.
			A slice of interface{} will have all it's elements as tags.

			Here, we just call CarsLinkID and use it's return value. We can use tags
			to modify a set of HTML elements - the sample program uses this tag
			to change the <a> tag's inner HTML dynamically.

			The second parameter is the HTML code to display inside the <a> element.
			Here we call CarsLinkText and have it return it.

			Finally, we provide a string with HTML attributes as the optional
			parameters. The optional parameters can contain other things as well,
			but strings are copied into the HTML closing tag as-is.
		-->
		{{$.A .G.CarsLink `href="/cars" class="btn btn-primary mb-3"`}}

		<form autocomplete="off">
			<!--
				JaWS Request objects have helper functions to allow easy data
				binding between your application and it's web UI.

				They take a jaws.[Type]Getter or jaws.[Type]Setter of the
				appropriate type: "String", "Html", "Bool", "Float" or "Time".
			-->
			<div class="mb-3">
				<label class="form-label">Text</label>
				{{$.Text .G.InputText `class="form-control"`}}
			</div>
			<div class="form-check mb-3">
				{{$.Checkbox .G.InputCheckbox `class="form-check-input"`}}
				<label class="form-check-label">Checkbox</label>
			</div>
			<div class="mb-3">
				<label class="form-label">Date</label>
				{{$.Date .G.InputDate}}
			</div>
			<div class="mb-3">
				<!--
					If jaws.Request doesn't have a helper function for a HTML tag, you can still
					use it with JaWS automation. Here, we use Request.Register() with a
					jaws.StringSetter as parameter.
				-->
				<textarea id="{{$.Register .G.InputTextArea}}" rows="4" cols="50"></textarea>
			</div>
			<div class="row mb-3">
				<label class="col-sm-2 form-label">Range</label>
				<div class="col-sm-10">
					<!-- 
						JaWS tags are used to logically link JaWS Elements together. When a
						Jaws.Dirty(tags) call is made, all Elements with one or more of the
						given tags have their JawsUpdate() method called eventually.

						Here, both UI Elements share the same uiInputRange{} for their data,
						and JaWS will automatically add that as a tag. So when the Range
						gets modified, the custom span is updated automatically.
					-->
					{{$.Range .G.InputRange `class="form-range align-bottom w-75"`}}
					{{$.UI .G.InputRange}}
				</div>
			</div>
			<!--
				Radio buttons require special handling because selecting
				one in a group of several de-selects all the others, and
				keeping this in sync with the server and other browsers
				takes care.

				You can either handle this yourself using Request.Radio(),
				using the boolean event functions for the individual radio
				buttons and coordinating in your server, or use the
				Request.RadioGroup(). Here, we will use the latter.

				RadioGroup() requires an object implementing jaws.RadioGrouper
				and returns a slice of jaws.Radio, which we use to render the HTML
				entities with the Radio() and Label() methods.
			-->
			{{range $.RadioGroup .G.InputRadioGroup1}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}
			{{range $.RadioGroup .G.InputRadioGroup2}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}

			<div class="mb-3">
				<label>Choose a pet:</label>
				{{$.Select .G.SelectPet `class="form-select"`}}
			</div>
			{{$.Button .G.InputButton `class="btn btn-primary m-3"`}}

			<!--
				This table of cars can be reordered using the buttons, but since we 
				iterate over .G.Cars manually using 'range', JaWS won't be able to
				add or remove rows to the table. For that, see "cars.html".
			-->
			<table class="table">
				<thead>
					<tr>
						<th scope="col">VIN</th>
						<th scope="col">Make</th>
						<th scope="col">Model</th>
						<th scope="col">Year</th>
						<th scope="col">Condition</th>
					</tr>
				</thead>
				<tbody>
					{{range .G.Cars}}
					<!--
						Using Request.Template() here with a string giving the
						template name requires us to set the Jaws.Template variable
						so the Request can use Template.Lookup() to resolve the name.
						We could also pass a *template.Template directly instead.

						When parsing "car_row.html", "$.Dot" will be the pointer
						to the current car, and "$" will be the *Element, which is
						also a *Request.

						Request.Template() adds both the dot value (here a *Car)
						and the *template.Template as JaWS tags.
					-->
					{{$.Template "car_row.html" .}}
					{{end}}
				</tbody>
			</table>
		</form>
	</div>
</body>

</html>