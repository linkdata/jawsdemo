<!doctype html>
<html lang="en">

<head>
	{{template "head.html" .}}
</head>

<!--
	When executing the template, we provide an *UiState as it's data parameter.
	The UiState, in turn, embeds a *jaws.Request without a member name, so it's
	methods are exposed directly on the UiState.

	You'll note that when we call those methods, we prefix the method with "$",
	which is the template syntax for "use the top-level data parameter".
-->

<body>
	{{template "header.html" .}}
	<div class="container">
		<!-- if Bootstrap is in use this marks where jaws UI alerts should be rendered -->
		<div id="jaws-alerts"></div>

		<!--
			JaWS allows several ways to register a HTML element and render it's HTML code.
			If you don't need to listen to events from the client browser, the following
			method may be a good choice. 

			It calls jaws.Request.A() via UiState.Request. Two parameters are required,
			plus a variable number of optional parameters.
			
			The first parameter is the tags you want to associate with the UI element.
			Tags can be anything (interface{}), but we treat some types special:

			If a string is given, it is split on spaces into multiple tags.
			For a slice of strings, we iterate over them and again split on spaces.
			A slice of interface{} will have all it's elements as tags.

			Here, we just call CarsLinkID and use it's return value. We can use tags
			to modify a set of HTML elements - the sample program uses this tag
			to change the <a> tag's inner HTML dynamically.

			The second parameter is the HTML code to display inside the <a> element.
			Here we call CarsLinkText and have it return it.

			Finally, we provide a string with HTML attributes as the optional
			parameters. The optional parameters can contain other things as well,
			but strings are copied into the HTML closing tag as-is.
		-->
		{{$.A .CarsLinkID .CarsLinkText `href="/cars" class="btn btn-primary"`}}

		<form autocomplete="off">
			<!--
				JaWS Request objects have helper functions to allow easy data
				binding between your application and it's web UI.

				The first parameter is the tag item, as above. We pass nil here
				because we don't need to update these programatically using tags.
				
				The second parameter is a jaws.ValueProxy or a `*atomic.Value`
				(which will get wrapped with a jaws.AtomicValueProxy).
			-->
			<div class="mb-3">
				<label class="form-label">Text</label>
				{{$.Text nil .G.InputText `class="form-control"`}}
			</div>
			<div class="form-check mb-3">
				{{$.Checkbox nil .G.InputCheckbox `class="form-check-input"`}}
				<label class="form-check-label">Checkbox</label>
			</div>
			<div class="mb-3">
				<label class="form-label">Date</label>
				{{$.Date nil .G.InputDate}}
			</div>
			<div class="mb-3">
				<!--
					If jaws.Request doesn't have a helper function for a HTML tag, you can still
					use it with JaWS automation. Here, we use Request.Register() with an event 
					function parameter to have JaWS call the function returned by OnInputTextArea()
					when the textarea data changes.

					That function then uses the tag returned from .G.InputTextAreaID to distribute the
					entered text to other Requests.
				-->
				<textarea jid="{{$.Register .G.InputTextAreaID .G.OnInputTextArea}}" rows="4" cols="50">{{.G.InputTextArea}}</textarea>
			</div>
			<div class="row mb-3">
				<label class="col-sm-2 form-label">Range</label>
				<div class="col-sm-10">
					{{$.Range "linkedrange" .G.InputRange `class="form-range align-bottom w-75"`}}
					{{$.Span "linkedrange" .G.InputRange}}
				</div>
			</div>
			<!--
				Radio buttons require special handling because selecting
				one in a group of several de-selects all the others, and
				keeping this in sync with the server and other browsers
				takes care.

				You can either handle this yourself using Request.Radio(),
				using the boolean event functions for the individual radio
				buttons and coordinating in your server, or use the
				Request.RadioGroup(). Here, we will use the latter.

				RadioGroup() requires an object implementing jaws.RadioGrouper
				and returns a slice of jaws.Radio, which we use to render the HTML
				entities with the Radio() and Label() methods.
			-->
			{{range $.RadioGroup .G.InputRadioGroup1}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}
			{{range $.RadioGroup .G.InputRadioGroup2}}
				<div class="form-check">
				{{.Radio `class="form-check-input"`}}
				{{.Label `class="form-check-label"`}}
				</div>
			{{end}}

			<div class="mb-3">
				<label>Choose a pet:</label>
				{{$.Ui .G.SelectPet `class="form-select"`}}
			</div>
			{{$.Ui .G.InputButton `class="btn btn-primary mt-3"`}}

			<!--
				What this does is left as an exercise to the reader.
				Hint: It's connected to the mystical button in "cars.html".
			-->
			{{$.OnEvent .G.SetInputButtonID .G.OnSetInputButton}}
		</form>
	</div>
</body>

</html>