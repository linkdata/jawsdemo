<!doctype html>
<html lang="en">

<head>
	{{template "head.html" .}}
</head>

<!--
	When executing the template, we provide an *UiState as it's data parameter.
	The UiState, in turn, embeds a *jaws.Request without a member name, so it's
	methods are exposed directly on the UiState.

	You'll note that when we call those methods, we prefix the method with "$",
	which is the template syntax for "use the top-level data parameter".
-->

<body>
	{{template "header.html" .}}
	<div class="container">
		<!-- if Bootstrap is in use this marks where jaws UI alerts should be rendered -->
		<div id="jaws-alerts"></div>

		<!--
			JaWS allows several ways to register a HTML element and render it's HTML code.
			If you don't need to listen to events from the client browser, the following
			method may be a good choice. 

			It calls jaws.Request.A() via UiState.Request. The "nil" argument here means
			no events will be forwarded from the client.

			If you did want to forward events, and want to use this syntax, then that
			argument would have to be a function returning a jaws.ClickFn function.
			This is because the Go template package won't allow you to pass a function
			as an argument; instead it will be invoked.
		-->
		{{$.A .CarsLinkID .CarsLinkText nil `href="/cars" class="btn btn-primary"`}}

		<form autocomplete="off">
			<div class="mb-3">
				<!--
					If you prefer to move data references away from the HTML template
					another option is to use jaws.Request.Ui(), which accepts an
					object implementing the "jaws.Ui" interface and zero or more
					strings (normally a list of HTML attributes).

					This allows for building types for generic use, and then
					use those types directly in your structures instead of the
					primitive data types.

					.G.InputText here is an example of one such implementation.
				-->
				<label class="form-label">Text</label>
				{{$.Ui .G.InputText `class="form-control"`}}
			</div>
			<div class="mb-3">
				<!--
					If jaws.Request doesn't have a helper function for a HTML tag, you can still
					use it. Here, we use Request.OnInput() to have JaWS call the function returned by
					OnInputTextArea() when the textarea data changes.
				-->
				<textarea jid="{{.G.InputTextAreaID}}" rows="4" cols="50">{{.G.InputTextArea}}</textarea>
				{{$.OnInput .G.InputTextAreaID .G.OnInputTextArea}}
			</div>
			<div class="row mb-3">
				<label for="{{.G.InputRangeID}}" class="col-sm-2 form-label">Range</label>
				<div class="col-sm-10">
					<!--
						Previous UI elements have consisted of only one HTML element,
						but this one shows that you can of course return HTML from
						JawsUi() that renders several and use an input event function
						to them in synch.
					-->
					{{$.Ui .G.InputRange `class="form-range align-bottom w-75"`}}
				</div>
			</div>
			<div class="form-check mb-3">
				{{$.Ui .G.InputCheckbox `class="form-check-input"`}}
			</div>
			<div class="mb-3">
				{{$.Ui .G.InputDate `class="form-label"`}}
			</div>
			<!--
				Here we're using the uiInputRadio type to handle both data,
				HTML rendering and events from the browser.
			-->
			{{$.Ui .G.InputRadioGroup `class="form-check-input"`}}
			<div class="mb-3">
				{{$.Ui .G.SelectPet `class="form-select"`}}
			</div>
			{{$.Ui .G.InputButton `class="btn btn-primary mt-3"`}}

			<!--
				What this does is left as an exercise to the reader.
				Hint: It's connected to the mystical button in "cars.html".
			-->
			{{$.OnEvent .G.SetInputButtonID .G.OnSetInputButton}}
		</form>
	</div>
</body>

</html>